# 一、进程与线程

### 1.CPU时间片

- cpu分配给每个程序的时间，每个线程被分配一个时间段，成为时间片
- 单核CPU只能实现并发，要想真正实现并行，需要多核CPU

### 2.进程

- 正在运行的程序。一个进程产生一块独立的空间，进程之间相互独立，互不影响
- 时间戳：格林威治时间1970年1月1日0时0分0秒。time.time()——得到时间戳
- time.localtime(time.time())——得到当前的时间。

单进程：就是平常的执行顺序

多进程：就是如下所示

```python
import time
import multiprocessing

def new_time():
    return time.asctime(time.localtime(time.time()))


def func(x,y):
    print(x+y)
    print('func_start',new_time())
    time.sleep(5)
    print('func_end', new_time())

print('main_start',new_time())
p1 = multiprocessing.Process(target=func,args=(1,2))
p1.start()
time.sleep(5)#模拟耗时操作，
print('main_end',new_time())
#一共耗时5秒钟。
```

- target：表示该进程需要执行的任务，并让子进程执行他所需要的任务。args：需要的是元组类型，并进行参数传递。
- 进程数多于核心数是没有效果的，cpu几核的就是分担几个耗时任务

### 3.线程

- 一个程序可以有多个进程，每个进程可以有多个线程，但是至少有一个进程和线程。
- 线程共享同个地址空间。

多线程——跟多进程模块是差不多的。

```python
import time
import threading

def new_time():
    return time.asctime(time.localtime(time.time()))

def func(x,y):
    print(x+y)
    print('func_start',new_time())
    time.sleep(5)
    print('func_end', new_time())

print('main_start',new_time())
p1 = threading.Thread(target=func,args=(1,2))
p1.start()
time.sleep(5)#模拟耗时操作，
print('main_end',new_time())
```

- 多线程不适合解决计算密集型的情形，但是适合IO密集型的场景
- 因为遇到阻塞会实行自动切换。

GIL全局解释锁——让任何一个进程中只有一个线程去执行。相当于是并发。

### 4.实现服务器并发

#### 4.1多进程实现并发服务器

```python
import socket
import multiprocessing
'''
主进程左连接客户端，生成对等套接字，通道连接
创建一个子进程，接收客户端
'''
def f_recv(conn):
    while True:
        data = conn.recv(1024)
        if data:
            print(data)
            conn.send(data)
        else:
            conn.close()
            break



def f_accept():
    sever = socket.socket()
    sever.bind(('127.0.0.1',4546))
    sever.listen(10)

    while True:
        conn,addr =sever.accept()
        p1 = multiprocessing.Process(target=f_recv,args=(conn,))
        p1.start()
if __name__=='__main__':
    f_accept()
```

