# 进程与线程补充

### 1.join方法

- 进程或者线程添加join方法后，会等待子任务结束，如果没有结束会一直阻塞，直到子任务结束。
- 一般是放在最后面的。
- 等待子任务结束，进程与线程都有的

```python
import time
import multiprocessing

def new_time():
    return time.asctime(time.localtime(time.time()))


def func(x,y):
    print(x+y)
    print('func_start',new_time())
    time.sleep(5)
    print('func_end', new_time())

print('main_start',new_time())
p1 = multiprocessing.Process(target=func,args=(1,2))
p1.start()
p1.join()   #等待子任务执行完毕，会进行阻塞
time.sleep(5)#模拟耗时操作，
print('main_end',new_time())
```

### 2.获取当前进程

```python
import time
import multiprocessing

def new_time():
    return time.asctime(time.localtime(time.time()))


def func(x,y):
    print(x+y)
    print('func_start',new_time())
    time.sleep(5)
    print('func_end', new_time())
if __name__ == '__main__':
    print(multiprocessing.current_process())    #获取当前进程对象
    print('main_start',new_time())
    p1 = multiprocessing.Process(target=func,args=(1,2))
    p1.start()
    p1.join()   #等待子任务执行完毕，会进行阻塞
    time.sleep(5)#模拟耗时操作，
    print('main_end',new_time())
```

### 3.获取子进程的名字

```python
import time
import multiprocessing

def new_time():
    return time.asctime(time.localtime(time.time()))


def func(x,y):
    print(x+y)
    print('func_start',new_time())
    time.sleep(5)
    print('func_end', new_time())
if __name__ == '__main__':
    print('main_start',new_time())
    p1 = multiprocessing.Process(target=func,args=(1,2))
    print(p1.name)
    p1.name='进程一号'
    print(p1.name)
    p1.start()
    time.sleep(5)#模拟耗时操作，
    print('main_end',new_time())
```

### 4.终止任务

- 可以在主进程结束之后，强制结束子进程
- 但是线程不能终止，只能等待结束。

```python
import time
import multiprocessing

def new_time():
    return time.asctime(time.localtime(time.time()))


def func(x,y):
    print(x+y)
    print('func_start',new_time())
    time.sleep(5)
    print('func_end', new_time())
if __name__ == '__main__':
    print('main_start',new_time())
    p1 = multiprocessing.Process(target=func,args=(1,2))
    p1.start()
    time.sleep(5)#模拟耗时操作，
    
    p1.terminate()  #终止p1子进程
    print('main_end',new_time())
```

### 5.进程的PID

- 在Linux1中，只要进程一创建，系统就会分配一个PID，在运行过程中，PID不会改变。
- 可以通过PID查看进程对资源的使用情况，也可以控制进程的运行.
- 进程的pid是不会改变的，只有在start后才能有pid

```python
import time
import multiprocessing

def new_time():
    return time.asctime(time.localtime(time.time()))


def func(x,y):
    print(x+y)
    print('func_start',new_time())
    time.sleep(5)
    print('func_end', new_time())
if __name__ == '__main__':
    print('main_start',new_time())
    p1 = multiprocessing.Process(target=func,args=(1,2))
    print('before start',p1.pid)
    p1.start()
    print('after start', p1.pid)
    time.sleep(5)#模拟耗时操作，
    p1.terminate()  #终止p1子进程
    print('main_end',new_time())
```

### 6.线程的ident

- 类似于操作系统中进程的pid，是python解释器分配的。
- 进程是操作系统分配的。

### 7.生存周期

```python
import time
import multiprocessing

def new_time():
    return time.asctime(time.localtime(time.time()))


def func(x,y):
    print(x+y)
    print('func_start',new_time())
    time.sleep(5)
    print('func_end', new_time())
if __name__ == '__main__':
    print('main_start',new_time())
    p1 = multiprocessing.Process(target=func,args=(1,2))
    print(p1.is_alive())
    p1.start()
    print(p1.is_alive())
    p1.join()
    print(p1.is_alive())
    time.sleep(5)#模拟耗时操作，
    print('main_end',new_time())
```

### 8.守护模式

- 开启守护模式之后，主进程结束，子进程自动结束。

```python
import time
import multiprocessing

def new_time():
    return time.asctime(time.localtime(time.time()))


def func(x,y):
    print(x+y)
    print('func_start',new_time())
    time.sleep(5)
    print('func_end', new_time())
if __name__ == '__main__':
    print('main_start',new_time())
    p1 = multiprocessing.Process(target=func,args=(1,2),daemon=True)    #开启守护模式
    p1.start()
    time.sleep(5)#模拟耗时操作，
    print('main_end',new_time())
```

# 面向对象编程

- 自定义进程对象，完成多进程并发操作redis数据库。
- redis高速存储数据库，并发操作。

```python
import redis
import multiprocessing
"""
自定义：
    通过class关键字定一个类
    要继承继承类
"""
class RedisProcess(multiprocessing.Process):
    def __init__(self,db,key,values):
        super().__init__()#调用父类的方法，创造子进程，实例化创建进程
        self.connect = redis.StrictRedis(db=db) #本地连接，只需要指定一个数据库就可以
        self.key = key
        self.values = values
    def set(self):
        self.connect.set(self.key,self.values)
    def get(self):
        return self.connect.get(self.key)
    def run(self):
        self.set()
        self.get()
```

