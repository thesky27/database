# 协程

### 一、问题

- 如果没有设置为·非阻塞套接字，recv会阻塞
- 设置完非阻塞套接字后，如果客户端保持连接，但是没有发送数据，recv会报异常，BlockingIDError
- 如果客户端连接之后进行关闭，期间没有发送数据，recv没有报错，也不会报异常，而是直接返回一个空字节的数据。
- 所以需要用断言来处理这个错误。

### 二、回顾迭代器

```python
li = [1,2,3,4]
li1 = iter(li)#生成迭代器对象
print(next(li1))
#yield:如果函数里有yield关键字，那么执行这个函数返回的生成器对象（迭代）
def fun():
    yield 5
    yield 2
    yield 3
res = fun()
 print(next(res))
#生成器 generator 新用法 yield 可以单独进行使用
#实现信息的传递输入与输出
#debug 需要打断点F7查看下一步
def func():
    while True:
        y = yield	#yield可以单独使用，等待传入的数据
        print(y)
res = func()
next(res)	#执行func函数，遇到yield暂停预激活
res.send('123')
```

yield功能：暂停和返回

### 三、用yield实现轮询切换

- yield用来保存状态，next来处理目前的状态



```python
from time import sleep

def consumer():
    while True:
        x = yield
        sleep(2)
        print('处理了数据：',x)

def producer():
    g = consumer()
    next(g)
    for i in range(20):
        print('发送了数据：',i)
        g.send(i)

producer()
```

### 四、协程

#### 4.1greenlet的使用

- 实质上是轻量级的线程，是在单线程下，无法利用单核
- 修改共享数据不需要加锁，单线程内实现并发的效果

第三方库：greenlet

```python
from greenlet import greenlet
from time import sleep

def consumer():
    while True:
        x= pro.switch()	#等待数据的接收
        sleep(2)
        print('处理了数据：',x)
def producer():
    for i in range(20):
        print('发送了数据：',i)
        con.switch(i)		#将数据发送给消费者
#将任务交给greenlet
con = greenlet(consumer)
pro = greenlet(producer)
con.switch()	#让消费者首先处于等待状态。
```

- 没有解决io阻塞的问题，但是可以更方便地实现并发

#### 4.2gevent实现并发服务器

**gevent封装了epoll和greenlet，实现了io阻塞的自动切换**

```python
from gevent import monkey
monkey.patch_all()
import gevent
import socket

def func(conn):
    while True:
        data = conn.recv(1024)
        if data:
            print(data)
            conn.send(data)
        else:
            conn.close()
            break

sever = socket.socket()
sever.bind(('127.0.0.1',8989))
sever.listen(10)
while True:
    conn,addr = sever.accept()
    #生成一个协程,并将conn作为参数传入
    gevent.spawn(func,conn)
```

#### 4.3实现通信

```python
from gevent import monkey   #猴子补丁
from time import sleep
monkey.patch_all()  #补丁的编辑，临时修改一些内容，必须放在gevent的前面
import gevent
from gevent.queue import Queue

def producer(queue):
    for i in range(20):
        queue.put(i)
        print('生产了数据：',i)
def consumer(queue):
    while True:
        x = queue.get()
        sleep(1)
        print('处理了数据：',x)

queue =Queue(3)
#创建一个携程,gevent会自动切换，不需要用switch进行切换
pro = gevent.spawn(producer,queue)
con = gevent.spawn(consumer,queue)
gevent.joinall([pro,con])
```

#### 4.4异步实现

- 与同步相对应，指让CPU暂时搁置当前的请求响应，处理下一个请求。

```python
from gevent import monkey
from time import sleep
from gevent import spawn,joinall
monkey.patch_all()


def task(pid):
    sleep(1)
    print('任务执行：',pid)

def synch():
    for i in range(10):
        task(i)
def asynch():
    spawn_all = []
    for i in range(10):
        spawn_all.append(spawn(task,i))
    joinall(spawn_all)	#等待所有任务结束
```

- 最后直接使用gevent就可以了

