# 一、网络编程

### 1.计算机网络

- 将地理位置不同的具有独立功能地多台计算机及其外部设备，通过通信线路连接起来，在协议的管理和协调下，实现资源共享和信息传递。

网络编程：用来实现网络互连的不同计算机运行程序可以进行数据交换

### 2.网络模型

计算机网络之间以何种规则进行通信。分为OSI模型和TCP/IP参考模型

#### 2.1OSI：

- 应用层：电脑屏幕看到的东西，产生数据。
- 表示层：做数据进行处理，加密与解密，压缩与解压，编码。
- 会话层：通过传输层建立数据传输的通路，发起会话和接受会话，在传输过程维持会话
- 传输层：数据连接与传输，用一个寻址机制标识一个特定的应用程序（端口）——分成数据段
- 网络层：基于网络层地址（ip地址）进行不同网络系统间的路径选择——进行数据的分割与重新组合，形成新的数据包
- 数据链路层：数据进行mac地址（网卡地址）封装与解封装，使用接收系统的硬件地址和物理地址来寻址，承上启下。——数据帧
- 物理层：物理设备：光纤，同轴电缆，双绞线，网卡，中继器，集线器等——比特数据

#### 2.2TCP/IP：

- 应用层——应用层，表示层，会话层合并——http：超文本传输协议，web服务器之间传输数据的协议，ftp:文件传输协议。smtp：简单邮件传输协议，pop:邮件协议，telent:远程登录协议。DNS：域名系统，域名与IP地址的转换。
- 传输层
- 网络层
- 数据链路层——数据链路层，物理层合并

**双方要遵守相同的协议，才能进行信息交流**

### 3.传输层

#### 3.1TCP

- 通过三次握手建立稳定链接。应用数据分割成最合适的数据进行发送
- 连接可靠，不易出现乱序，丢失等现象
- 连接和校验需要时间，效率低下

**三次握手**

1. 客户端发送SYN报文给服务端，进入SYN——SEND状态
2. 服务端接收到报文，回应一个SYN ACK报文，进入SYN——RECV状态
3. 客户端接收到服务端地SYN报文，回应一个ACK报文，进入连接状态。

#### 3.2UDP

- 一次性发送所有的协议，可能出现数据丢失现象。

### 4.网络层

有网关，路由器

- IP地址其实是虚拟地址，会通过ARP协议转换为网卡地址
- 计算机只能识别二进制的数据，IP是一个二进制数据。IPV4长度为32位，分为4段，十进制标识。
- IPV6长度是IPV4的四倍，以16进制标识，分为八段，

IP地址：有网络号段和主机号段。127.0.0.1：本机地址，0.0.0.0：任意地址。ping IP地址：测试与该IP地址是否相同



端口是软件的身份证，用来区分不同的软件，最大时2的16次方减一

```python
#服务端配置
import socket
server = socket.socket()
server.bind(('127.0.0.1',8989))	#绑定要运行的服务端的IP地址,端口任意设置
server.listen(10)	#设置最大监听数量
result = server.accept()	#创建连接通道，获取对等套接字，返回的是一个元组，第一个是对等连接套接字，第二个是客户端的IP加上端口
conn,addr = result #拆包
conn.recv(1024)	#设置最大接收字节数
conn.send(b'返回')	#返回给客户端数据

#数据要对等	
conn.close()
server.close()

#客户端配置
import socket
client = socket.socket()
client.connect(('127.0.0.1',8989))	#连接服务器开辟出的端口地址
client.send(b'hello')	#发送字节数据
client.close()
```

![image-20211020212829055](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20211020212829055.png)

- 传输的必须是字节数据——字符串转字节bytes(info,encoding='utf8')

# 二、I/O多路复用

### 1.数据流

- 定义：是一组有序的， 有起点和终点的字节的数据序列，包括输入流和输出流。
- 输入流只能读，不能写，从键盘或文件中获取数据，输出流只能写，不能读，向显示器打印机等写入东西。第一人称是机器。
- I/O——在信息的交换过程中，对这些流进行数据的收发操作。fd就是文件描述符，一个整数，就是对整数的操作。

### 2.I/O交互

- 用户空间——用户程序和应用程序以及代码
- 内存空间——内核空间，操作系统和驱动程序
- 硬盘空间

### 3.基本IO模型

IO操作以何种规则进行操作，分为阻塞io，非阻塞io，多路复用io

#### 3.1阻塞IO模型

阻塞IO就是专心做一件事情，阻塞的时候不做其他事情，做完这一件事情，才会去做其他事情。

- 优点：进程阻塞挂起，不会消耗cpu资源，能够及时响应每个操作，难度低
- 缺点：不适合并发量大的应用开发。进程阻塞时不能进行其他操作

```python
#阻塞IO，同时建立两个套接字
import socket

server = socket.socket()
server.bind('127.0.0.1',8989)
server.listen(10)

all_conn = []

for i in range(2):
    conn,addr = server.accept()
    all_conn.append()


for conn in all_conn:
    #得到所有的对等连接套接字
    data = conn.recv(1024)
    if data:
        print(data)
    else:
        
        all_conn.remove(conn)
    conn.close()
server.close()
```

#### 3.2非阻塞IO模型

- 优点：在等待线程的时候去做其他任务，效率高。
- 缺点：消耗大，轮询加延迟，而任务可能就在中间任意时间完成

```python
#非阻塞IO
# -*- coding: utf-8 -*-
# @Time: 2021/10/29 19:19
# @Author: 枫无痕
# @Email: thesky_27@163.com
# @File: server01.py
# @Software: PyCharm
import socket
from time import sleep
server = socket.socket()

#设置为非阻塞套接字，需要i在其他操作之前设置
server.setblocking(False)

server.bind('127.0.0.1',8989)
server.listen(10)

# while True:
#     try:
#         conn,addr = server.accept()
#         conn.recv(1024)
#     except BlockingIOError:
#         print("做其他事情")
#         sleep(1)
all_conn = []
while True:
    try:
        conn,addr = server.accept()
        conn.setblocking(False) #将对等套接字设置为非阻塞接字
        all_conn.append(conn)
    except BlockingIOError:
        pass
    except Exception as E:
        print(f"发生了未知异常{E}")

    #接收数据
    for conn in all_conn:
        try:
            data = conn.recv(1024)
            if data:
                print(data)
                conn.send(data)
            else:
                conn.close()
                all_conn.remove(conn)
        except BlockingIOError:
            pass
        except Exception as E:
            print(f"发生了未知异常{E}")
```

- 同一时间段发生多个事情叫做并发，同一时刻只有一条指令执行，但是是快速的切换执行，宏观是一起执行的，微观不是同时执行的。
- 同一时间点发生多件事情叫做并行。连接客户端和接受数据是并发执行的。

#### 3.3IO多路复用模型

雇佣人来查看与有没有上钩

- 优点：占用资源少，消耗CPU少
- 缺点：需要两个系统调用

原理：select/epoll这个function会不断轮询所负责的socket，有数据之后就会通知用户。

epoll是最佳的打工仔，是一个惰性事件回调，用户自己去调用，是linux最好的IO多路复用器，但是只有linux有。

```python
#多路复用
import socket,selectors #IO多路复用选择器模块，

epoll_select = selectors.EpollSelector()    #实例化
selectors.DefaultSelector() #默认选择器，自动根据不同操作系统选择
server = socket.socket()
server.bind('127.0.0.1',8989)
server.listen(10)

def f_accept(server):
    conn,addr = server.accept() #生成对等连接套接字
    epoll_select.register(conn, selectors.EVENT_READ, f_recv)


def f_recv(conn):
    data = conn.recv(1024)
    if data:
        print(data)
    else:
        conn.close()

#selectors.EVENT_READ 有事件发生时，调用回调函数，第三个参数
epoll_select.register(server,selectors.EVENT_READ,f_accept)

while True:
    events = epoll_select.select()   #查询,返回的是一个列表，保存一个元组，
    for key,mask in events:
        func = key.data     #函数体
        conn = key.fileobj  #已经注册的套接字
        func(conn)      #调用f_accept方法。

```

