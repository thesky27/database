

# 并发通信

### 1.进程通信隔离

主要是操作的空间是不同的，子进程和主进程的空间不是共用的。各个进程的空间是独立的.

注意：进程在Windows中运行会报错。

```python
from multiprocessing import Process
var = 10
def func():
    global var
    var +=1
    print(var)
    return var
p1 = Process(target=func)
p1.start()
p1.join()
print(var)

#子进程var的值：11
#主进程var的值：10
```

### 2.进程创建公共空间

```python
from multiprocessing import Process
from multiprocessing import Manager
mg = Manager()   #实例化一个服务器的进程（管理器）
print("在var之前，上面没问题")
li_var = mg.list()   #在进程中开辟一个列表空间，会返回一个代理（公共的列表空间）
var = 10
def func(li):
    global var
    var += 1
    print('这是函数里面的var',var)
    li.append(var)
    return var
p1 = Process(target=func,args=(li_var,))
p1.start()
p1.join()
print(li_var[0])
```

### 3.线程通信

```python
from threading import Thread
var = 10
def func():
    global var
    var += 1
    print('这是函数里面的var',var)
t1 = Thread(target=func)
t1.start()
t1.join()
print(var)
#主线程和子线程都是11
```

- 线程之间的数据是可以抢断的。资源的抢夺是不稳定的。

```python
from threading import Thread
var = 1
def f1():
    global var
    for i in range(1000):   #可能会出现，一直循环，但是加不上去的情况
        var += 1

def f2():
    global var
    for i in range(1000):
        var -= 1
t1 = Thread(target=f1)
t2 = Thread(target=f2)

t1.start()
t2.start()

t1.join()
t2.join()

#两个值没有一个是对的。
```

- 于是，用线程去做的时候，要加锁

```python
from threading import Thread,Lock
lock = Lock()
var = 1
def f1():
    global var
    lock.acquire()  #加锁上锁
    for i in range(1000):   #可能会出现，一直循环，但是加不上去的情况
        var += 1
    lock.release()  #解锁

def f2():
    global var
    lock.acquire()  # 加锁上锁
    for i in range(1000):
        var -= 1
    lock.release()  # 解锁
t1 = Thread(target=f1)
t2 = Thread(target=f2)

t1.start()
t2.start()

t1.join()
t2.join()
#此时的结果是正确的
```

### 4.生产者与消费者模型

#### 4.1队列操作

数据类型的本质都是一个类，队列是一个新的数据类型，先进先出，获取后会被删除。

队列的获取和添加都会出现阻塞的情况。

#### 4.2多进程（队列）

```python
from multiprocessing import Process,Queue

import random
from time import sleep
q = Queue(4)

class Produser(Process):
    def __init__(self,queue):
        super().__init__()
        self.queue = queue
    def run(self):
        while True:
            item = random.randint(1,100)
            self.queue.put(item)
            print(f'生产者（用户）生成{item}')
            sleep(2)
class Consumer(Process):
    def __init__(self, queue):
        super().__init__()
        self.queue = queue

    def run(self):
        while True:
            item = self.queue.get()
            item *=10
            sleep(2)
            print(f'消费者（程序）处理后的数据{item}')
pr = Produser(q)
cu = Consumer(q)
cu1 = Consumer(q)
pr1 = Produser(q)
pr2 = Produser(q)
pr3 = Produser(q)
pr.start()
cu.start()
```

#### 4.3多线程（队列）

```python
from threading import Thread
from queue import Queue
import random
from time import sleep
q = Queue(4)

class Produser(Thread):
    def __init__(self,queue):
        super().__init__()
        self.queue = queue
    def run(self):
        while True:
            item = random.randint(1,100)
            self.queue.put(item)
            print(f'生产者（用户）生成{item}')
            sleep(2)
class Consumer(Thread):
    def __init__(self, queue):
        super().__init__()
        self.queue = queue

    def run(self):
        while True:
            item = self.queue.get()
            item *=10
            sleep(2)
            print(f'消费者（程序）处理后的数据{item}')

pr = Produser(q)
cu = Consumer(q)
cu1 = Consumer(q)
pr1 = Produser(q)
pr2 = Produser(q)
pr3 = Produser(q)
pr.start()
cu.start()
```

# 并发池（进程池与线程池）

### 1.可重复利用的单线程

- 线程只能使用一次，执行一次任务就丢失了。每次有新的任务都会创建一个线程，浪费
- 多个任务需要有存放记录的空间——列表，字典，集合，元组，队列，执行完毕后会进行删除。
- 考虑线程不结束，不消失，当空间有任务时对线程进行阻塞，线程就不会阻塞，再次对它进行操作，使用。

对于队列中

- 有一个计数器，q.join()——有元素就会阻塞，没有数据就不会阻塞。但是q.get()——还是会阻塞。
- q.task_one()——调用这个方法才会进行阻塞。
- q.join()——严格来说判断队列中的计数器是否为0

```python
from threading import Thread
from time import sleep
from queue import Queue


#定义多个函数模拟多任务
def f1(*args,**kwargs):
    sleep(3)    #模拟耗时操作
    print('任务一完成',args,kwargs)
def f2(*args,**kwargs):
    sleep(3)
    print('任务二完成',args,kwargs)

class MyThread(Thread):
    def __init__(self):
        super().__init__()
        self.daemon = True  # 开启任务，主线程结束，子线程自动终止。
        self.queue = Queue(3)
        self.start()        #在初始化的时候就开启线程
    def run(self) -> None:
        while True:
            func,args,kwargs = self.queue.get()
            func(*args,**kwargs)    #执行任务
            self.queue.task_done()  #刷新计数器，减一
    def submit_tasks(self,func,args=(),kwargs={}):
        #提交任务，将任务添加到队列中
        self.queue.put((func,args,kwargs))

    def join(self): #将线程的join方法更改为队列的join方法，也就是让主线程等待子线程变成，子线程完成任务才会终止
        self.queue.join()   #查看队列中是否有元素，有元素就会阻塞
```

- 但是以上只能是单线程处理多任务，需要线程池。

### 2.线程池

```python
from threading import Thread
from time import sleep
from queue import Queue


#定义多个函数模拟多任务
def f1(*args,**kwargs):
    sleep(3)    #模拟耗时操作
    print('任务一完成',args,kwargs)
def f2(*args,**kwargs):
    sleep(3)
    print('任务二完成',args,kwargs)

class MyThread(Thread):
    def __init__(self,n):
        self.queue = Queue(3)   #创建一个公共队列，存放任务
        for i in range(n):      #创建多个线程
            super().__init__()  #变成线程对象
            self.daemon = True  # 开启任务，主线程结束，子线程自动终止。
            self.start()        #在初始化的时候就开启线程
    def run(self) -> None:
        while True:
            func,args,kwargs = self.queue.get()
            func(*args,**kwargs)    #执行任务
            self.queue.task_done()  #刷新计数器，减一
    def submit_tasks(self,func,args=(),kwargs={}):
        #提交任务，将任务添加到队列中
        self.queue.put((func,args,kwargs))

    def join(self): #将线程的join方法更改为队列的join方法，也就是让主线程等待子线程变成，子线程完成任务才会终止
        self.queue.join()   #查看队列中是否有元素，有元素就会阻塞
```

python已经存在了线程池，上面的代码只是帮助我们去了解线程池的具体工作情况。线程池的使用具体如下

```python
from time import sleep
from multiprocessing.pool import ThreadPool

#定义多个函数模拟多任务
def f1(*args,**kwargs):
    sleep(3)    #模拟耗时操作
    print('任务一完成',args,kwargs)
def f2(*args,**kwargs):
    sleep(3)
    print('任务二完成',args,kwargs)

mt = ThreadPool(3)  #指定线程的个数
mt.apply_async(f1)
mt.apply_async(f2,args=(1,2),kwds={'a':1})  #提交任务

mt.close()  #关闭任务提交通道，写在任务提交代码的后面，在join之前
mt.join()   #等待线程池执行完毕
```

**进程池的使用就是将Thread这个模块改为Pool模块**

线程池返回的是一个对象，定义一个变量保存，然后用get方法去获取，这个地方也会阻塞

### 3.线程池实现并发服务器

**采用线程池**

```python
import socket
from multiprocessing.pool import ThreadPool
from multiprocessing import cpu_count
def socket_rev(conn):
    while True:
        data = conn.recv(1024)
        if data:
            print(data)
            conn.send(data)
        else:
            conn.close()
            break
if __name__ == "__main__":
    sever = socket.socket()
    sever.bind(('127.0.0.1',8989))
    sever.listen(20)
    n = cpu_count()
    pool = ThreadPool(n*2)
    while True:
        conn,recv = sever.accept()
        pool.apply(socket_rev(),args=(conn,))
```



**采用线程池和进程池实现并发服务器**



```python
from multiprocessing.pool import ThreadPool,Pool
from multiprocessing import cpu_count
import socket

def socket_rev(conn):
    while True:
        data = conn.recv(1024)
        if data:
            print(data)
            conn.send(data)
        else:
            conn.close()
            break

def thread_accept(n,server):
    thread_pool = ThreadPool(n*2)
    while True:
        conn,addr = server.accept() #建立通道的连接
        #将任务交给线程池
        thread_pool.apply_async(socket_rev,args=(conn,))

if __name__ == '__main__':
    server = socket.socket()
    server.bind('127.0.0.1',5898)
    server.listen(50)
    #创建进程池
    n = cpu_count()
    pool = Pool(n*2)
    for i in range(n*2):
        pool.apply_async(thread_accept,args=(n,server))#默认开启了守护模式,所以需要等待。
    pool.close()
    pool.join()
```

